{"version":3,"sources":["TurtleLine.js","TurtleShape.js","LSystem.js","Form.js","Home.js","Organisms.js","Garden.js","App.js","index.js"],"names":["TurtleLine","pathData","this","props","line","map","p","get","join","className","stroke","d","Component","TurtleShape","turtleLines","visibility","index","key","LSystem","sleep","milliseconds","Promise","resolve","setTimeout","state","turtleInstructions","Immutable","List","needsToGrow","currentRule","rule","instructions","axiom","addGrowSteps","grow","toLowerCase","turtleString","expandInstructions","runTurtle","i","loops","setState","prevState","push","inputString","outputString","replacements","split","subst","findString","replace","trim","newString","token","matched","replacement","angle","Math","PI","item","currentAngle","currentX","Number","startX","currentY","startY","locations","Stack","lines","step","c","point1","Map","x","y","cos","toRadians","sin","point2","currPos","X","Y","A","oldPos","first","pop","inGrowth","size","drawLSystem","nextProps","nextState","previousProps","previousState","turtle","Form","handleChange","event","target","name","value","submitForm","handleSubmit","initialState","type","onChange","onClick","Home","newRule","Organisms","set","resources","nitrogen","oxygen","carbonDioxide","rules","Garden","organisms","Object","assign","App","to","path","ReactDOM","render","document","getElementById"],"mappings":"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","file":"static/js/main.ac065b94.chunk.js","sourcesContent":["import React, { Component } from 'react'\n\nclass TurtleLine extends Component {  \n  render() {\n    const { line } = this.props\n    \n    const pathData = \"M \" + line\n      .map(p => p.get('x') + ' ' + p.get('y'))\n      .join(\" L \");\n\n    return <path className='path' stroke='black' d={pathData} />;\n  }\n}\n\nexport default TurtleLine;\n","import React, { Component } from 'react'\nimport TurtleLine from './TurtleLine'\n\nclass TurtleShape extends Component {  \n  \n  render() {\n    const turtleLines = this.props.turtleLines;\n    const visibility = this.props.visibility;\n    \n    return (\n      <div>\n      <svg className={visibility}>\n        {turtleLines.map((line, index) => (\n          <TurtleLine key={index} line={line} />\n        ))}\n      </svg>\n      </div>\n    );\n    \n  }\n}\n\nexport default TurtleShape;\n","import React, { Component } from 'react'\nimport Immutable from 'immutable'\nimport TurtleShape from './TurtleShape'\n\nclass LSystem extends Component {\n  constructor(props) {\n    /*\n      The propery handed in should be an object called \"rule\", with\n      the following keys:\n        axiom: The initial string\n        numloops: How many times to run the replacement algorithm\n        replacements: One or more comma-separated replacement rules, of the format \"X = Y\" \n        step: How many pixels to draw each line\n        angle: The angle to turn when turning\n        startX: The X position at which to start drawing\n        startY: The Y position at which to start drawing\n        grow: Boolean saying whether to draw the growing process or jump straight to the final design\n    */\n    super(props);\n    \n    /*\n      In this component's state, we'll keep track of the following:\n        turtleInstructions: A list of the expanded instructions (one entry for\n            each loop through the rewriting process)\n        turtleLines: A list of structures which contain the following:\n            visibility: The class names for the wrapping svg object \n            lines: A list of the actual TurtleLine components that will get rendered\n        needsToGrow: For complicated React reasons, a boolean indicating whether or not\n            we've gone through the \"growing\" render process for this particular L-System\n    */\n    this.state = {\n      turtleInstructions: Immutable.List(),\n      turtleLines: Immutable.List(),\n      needsToGrow: false,\n    }\n\n  }\n  \n  /*\n    The main function that will generate the turtle drawing instructions\n    for each iteration, and populate this.state accordingly.\n  */\n  drawLSystem() {\n    const currentRule = this.props.rule;  // The information about how to build the system\n    var instructions = currentRule.axiom; // The starting point\n    var addGrowSteps = true; // Whether or not to add all of the \"steps\" to show \"growth\"\n    if ('grow' in this.props) addGrowSteps = (this.props.grow.toLowerCase() === 'true');\n    \n    // Loop N times, and for each loop, expand the instructions\n    // and create the relevant TurtleLines\n    for (var i = 0; i < currentRule.loops; i++) {\n      const turtleString = this.expandInstructions(instructions);\n      const turtleLines = this.runTurtle(turtleString);\n      \n      // If we're supposed to add each of the growth \"steps\"\n      // or if this is the last step, add it to the state\n      var add = (addGrowSteps || i === currentRule.loops - 1);\n      if (add) {\n        // Add this loop's instructions and TurtleLines to our state\n        this.setState(prevState => {\n          return {\n            turtleInstructions: prevState.turtleInstructions.push(turtleString),\n            turtleLines: prevState.turtleLines.push(turtleLines),\n          };\n        });\n      }; \n      \n      // Reset the instructions to the current turtle string in preparation for the next loop\n      instructions = turtleString;\n    }\n    \n    // After we're done updating state with all of the appropriate turtle lines,\n    // indicate to ourselves that we need to grow. (i.e. to show the actual rendering of the lines)\n    this.setState(prevState => {\n        return {\n          needsToGrow: true,\n        };\n    });\n  }\n  \n  \n  /* \n    Expansion function for a given \"loop\" of instruction generation\n  */\n  expandInstructions(inputString) {\n    \n    var outputString = '';\n    var replacements = [];\n    const currentRule = this.props.rule;\n    \n    for(const replacement of currentRule.replacements.split(',')) {\n      const rule = replacement.split('=');\n      const subst = {findString: rule[0].replace(/\\(/,\"\").trim(), newString: rule[1].replace(/\\)/,\"\").trim()};\n      replacements.push(subst);\n    }\n    \n    for(const token of inputString) {\n      var matched = false;\n      for(const replacement of replacements) {\n        if (replacement.findString === token) {\n          matched = true;\n          outputString += replacement.newString;\n          break;\n        }  \n      }\n      if (! matched) outputString += token;\n    }\n    return outputString;\n  }\n  \n  /*\n    Utility function for converting to radians to make the math easier\n  */\n  toRadians(angle) {\n    return angle * (Math.PI / 180);\n  }\n  \n  /*\n    Function to send the turtle along the path of following a particular\n    instruction set and drawing out the lines necessary for it; note that\n    these lines are hidden to begin with, and need to go through the \"grow\"\n    process in order to be visible\n  */\n  runTurtle(item) {\n\n    const instructions = item;\n    const currentRule = this.props.rule;\n    \n    var currentAngle = 90;\n    var currentX = Number(currentRule.startX);\n    var currentY = Number(currentRule.startY);\n    var locations = Immutable.Stack();\n    \n    // This structure is what we'll ultimately add to this.state.turtleLines;\n    // note that it's hidden by default\n    var turtleLines = {\n      visibility: \"hidden drawArea\",\n      lines: Immutable.List(),\n    };\n    \n    const angle = Number(currentRule.angle);\n    const step = Number(currentRule.step);\n    \n    // For each character in the string\n    for(const c of instructions) {\n      if (c === 'F' || c === 'G') {\n        // If it's an \"F\" or a \"G\", add a line and move the turtle\n        const point1 = new Immutable.Map({x: currentX, y: currentY,});\n        currentX = currentX + step * Math.cos(this.toRadians(currentAngle));\n        currentY = currentY - step * Math.sin(this.toRadians(currentAngle));\n        const point2 = new Immutable.Map({x: currentX, y: currentY,});\n        \n        turtleLines.lines = turtleLines.lines.push(Immutable.List([point1, point2]));\n        \n      } else if (c === '+') {\n        // If it's a turn, change the angle\n        currentAngle += angle; // turn left\n      } else if (c === '-') {\n        currentAngle -= angle; // turn right)\n      } else if (c === '[') {\n        // Push current value of X,Y from locations\n        const currPos = {X: currentX, Y: currentY, A: currentAngle};\n        locations = locations.push(currPos);\n      } else if (c === ']') {\n        // Reset current value of X,Y to that popped from locations\n        const oldPos = locations.first();\n        locations = locations.pop();\n        currentX = oldPos.X;\n        currentY = oldPos.Y;\n        currentAngle = oldPos.A;\n      } else if (c === 'X' || c === 'Y') {\n        // For completeness; no-op\n      }\n    }\n    return turtleLines;\n  }\n  \n  \n  /*\n    Utility method for sleeping (ugh javascript)\n  */\n  sleep = (milliseconds) => {\n    return new Promise(resolve => setTimeout(resolve, milliseconds))\n  }\n  \n  /*\n    Function that will gradually show each of the sets of lines (the\n    svg objects) such that the system appears to \"grow\"\n  */\n  async grow(){\n    const turtleLines = this.state.turtleLines;\n    \n    this.setState(prevState => {\n        return {\n          needsToGrow: false,\n          inGrowth: true,\n        };\n    });\n    \n    for (var i = 0; i < turtleLines.size; i++) {  \n      \n      if (i !== 0) {\n        turtleLines.get(i-1).visibility = \"hidden drawArea\";\n      }\n      turtleLines.get(i).visibility = \"drawArea\";\n      this.setState(prevState => {\n        return {\n          turtleLines: turtleLines,\n        };\n      }); \n      await this.sleep(250);\n    }\n    \n  }\n  \n\n  // ----------- OVERRIDING COMPONENT METHODS BELOW HERE ----------------\n  \n  // Before it first loads, run the\n  // turtle to draw the needed lines.\n  componentWillMount() {\n    this.drawLSystem();\n  }\n  \n  // And, after everything is drawn and\n  // loaded, \"grow\" the system\n  componentDidMount() {\n    this.grow();\n  }\n  \n  \n  // We only want to actually update the component under three conditions:\n  // 1) If the rule has changed\n  // 2) If we need to \"grow\" the system\n  // 3) If we're actually in the process of growing the system\n  shouldComponentUpdate(nextProps, nextState) {\n    return nextProps.rule !== this.props.rule || this.state.needsToGrow || this.state.inGrowth;\n  }\n  \n  \n  // Every time an update happens, check to see if \n  // our parent has changed our rules and, if so, recreate\n  // the lines\n  componentDidUpdate(previousProps, previousState) {\n\n    // Because componentDidUpdate will get called on\n    // any update of state (including, for instance,\n    // adding a new line), only reset and redraw\n    // if the thing being changed is the rule. (Note\n    // that because we've overridden shouldComponentUpdate we \n    // should never get here in the first place, but we're\n    // being safe.)\n    if (previousProps.rule !== this.props.rule) {\n      // The rule has been changed;\n      // reset our state. \n      this.setState(prevState => {\n        return {\n          turtleInstructions: Immutable.List(),\n          turtleLines: Immutable.List(),\n          needsToGrow: false,\n          inGrowth: false,\n        };\n      }); \n      this.drawLSystem();\n    } else if (this.state.needsToGrow) {\n      // We need to grow! Call the \"grow\"\n      // function.\n      this.grow();\n    }\n  }\n  \n\n  /*\n   The actual render, finally!\n  */\n  render() {\n    const turtleLines = this.state.turtleLines;\n    \n    return (\n      <div>\n      {turtleLines.map((turtle, i) => (\n        <TurtleShape visibility={turtle.visibility} turtleLines={turtle.lines} />\n      ))}\n    </div>\n    );\n  }\n}\n\nexport default LSystem;\n","import React, { Component } from 'react'\n\nclass Form extends Component {\n  constructor(props) {\n    super(props)\n\n    this.initialState = {\n      angle: props.rule.angle,\n      step: props.rule.step,\n      axiom: props.rule.axiom,\n      replacements: props.rule.replacements,\n      loops: props.rule.loops,\n      startX: props.rule.startX,\n      startY: props.rule.startY\n    }\n\n    this.state = this.initialState\n  }\n  \n  handleChange = event => {\n    const { name, value } = event.target\n  \n    this.setState({\n      [name]: value,\n    })\n  }\n  \n  submitForm = () => {\n    this.props.handleSubmit(this.state)\n  }\n  \n  render() {\n    const { angle,\n      step,\n      axiom,\n      replacements,\n      loops,\n      startX,\n      startY } = this.state;\n  \n    return (\n      \n      <div className=\"instructions\">\n      <h3>Instructions</h3>\n      <p>\n        To run an L-System, enter the required information and press \"submit\". Some notes:\n        <ul>\n        <li>The \"Replacement Rule\" should consist one or more comma-separated replacement rules, of the format \"( X = Y )\" -- see examples, below</li>\n        <li>The rules use the following symbols:\n          <ul>\n          <li>'F' and 'G' each draw a single line segment</li>\n          <li>'+' and '-' rotate the turtle to the left and right respectively (by the defined angle)</li>\n          <li>'[' and ']' store and recall a particular XY coordinate for the turtle (i.e. allow the turtle to return to a previous location)</li>\n          <li>'X' and 'Y' are no-ops and are used as placeholders in the rules</li>\n          <li>All other characters are ignored</li>\n          </ul>\n        </li>\n        <li>PLEASE don't use more than 6 recursions!</li>\n        <li>If you're having trouble seeing the entire resulting drawing, try reducing the \"Step Size\" to make it smaller</li>\n        <li>NOTE: INPUTS ARE NOT CURRENTLY BEING SANITIZED! If you get an error, probably it's a parsing issue. Check your rules in particular.</li>\n        </ul>\n      </p>\n      \n      <hr />\n      \n      <h3>L-System rules</h3>\n      <form>\n        <label>Axiom (initial string)</label>\n        <input\n          type=\"text\"\n          name=\"axiom\"\n          size=\"10\"\n          value={axiom}\n          onChange={this.handleChange} />\n        \n        <br />\n        <label>Replacement Rules</label>\n        <input\n          type=\"text\"\n          name=\"replacements\"\n          size=\"50\"\n          value={replacements}\n          onChange={this.handleChange} />\n        \n        <br />\n        <label>Angle for Turns</label>\n        <input\n          type=\"text\"\n          name=\"angle\"\n          size=\"5\"\n          value={angle}\n          onChange={this.handleChange} />\n          \n        <br />\n        <label>Step Size (length of line)</label>\n        <input\n          type=\"text\"\n          name=\"step\"\n          size=\"5\"\n          value={step}\n          onChange={this.handleChange} />\n          \n        <br />\n        <label>Loops (number of recursions)</label>\n        <input\n          type=\"text\"\n          name=\"loops\"\n          size=\"5\"\n          value={loops}\n          onChange={this.handleChange} />\n          \n        <br />\n        <label>Initial X Position</label>\n        <input\n          type=\"text\"\n          name=\"startX\"\n          size=\"5\"\n          value={startX}\n          onChange={this.handleChange} />\n        <label>Initial Y Position</label>\n        <input\n          type=\"text\"\n          name=\"startY\"\n          size=\"5\"\n          value={startY}\n          onChange={this.handleChange} />\n          \n        <br />\n        <input type=\"button\" value=\"Submit\" onClick={this.submitForm} />\n      </form>\n      \n      <hr />\n      \n      <h3>Examples</h3>\n      <p>\n      <ul>\n      <li>Sierpinski triangle:\n        <ul>\n          <li>Axiom: F-G-G</li>\n          <li>Replacement Rules: (F = F-G+F+G-F), (G = GG)</li>\n          <li>Angle: 120</li>\n          <li>Step Size: 7</li>\n          <li>Loops: 6</li>\n          <li>Initial X: 10</li>\n          <li>Initial Y: 600</li>\n        </ul>\n      </li>\n      \n      <li>Fractal plant:\n        <ul>\n          <li>Axiom: X</li>\n          <li>Replacement Rules: (X = F+[[X]-X]-F[-FX]+X), (F = FF)</li>\n          <li>Angle: 25</li>\n          <li>Step Size: 3</li>\n          <li>Loops: 6</li>\n          <li>Initial X: 200</li>\n          <li>Initial Y: 600</li>\n        </ul>\n      </li>\n      \n      <li>Binary tree:\n        <ul>\n          <li>Axiom: F</li>\n          <li>Replacement Rules: (G = GG), (F = G[+F]-F)</li>\n          <li>Angle: 25</li>\n          <li>Step Size: 4</li>\n          <li>Loops: 7</li>\n          <li>Initial X: 300</li>\n          <li>Initial Y: 600</li>\n        </ul>\n      </li>\n      \n      \n      <li>Koch curve\n        <ul>\n          <li>Axiom: F</li>\n          <li>Replacement Rules: (F = F+F-F-F+F)</li>\n          <li>Angle: 90</li>\n          <li>Step Size: 4</li>\n          <li>Loops: 4</li>\n          <li>Initial X: 300</li>\n          <li>Initial Y: 600</li>\n        </ul>\n      </li>\n      \n      \n      <li>Dragon curve\n        <ul>\n          <li>Axiom: FX</li>\n          <li>Replacement Rules: (X = X+YF+), (Y = -FX-Y)</li>\n          <li>Angle: 90</li>\n          <li>Step Size: 4</li>\n          <li>Loops: 12 <i>(Dragons get special dispensation for extra loops)</i></li>\n          <li>Initial X: 300</li>\n          <li>Initial Y: 200</li>\n        </ul>\n      </li>\n      \n      </ul>\n      </p>\n      </div>\n    );\n  }\n}\n\n  export default Form;","import React, { Component } from 'react'\nimport LSystem from './LSystem'\nimport Form from './Form'\n\nclass Home extends Component {\n  constructor(props) {\n    super(props)\n  \n    this.initialState = {\n      // Binary tree\n      rule: {\n        angle: '25',\n        step: '4',\n        axiom: 'F',\n        replacements: '(G = GG), (F = G[+F]-F)',\n        loops: '7',\n        startX: '300',\n        startY: '600'\n      }\n    }\n    \n    this.state = this.initialState\n  }\n\n  handleSubmit = newRule => {\n    this.setState({ rule: newRule });\n  }\n\n  \n  render() {\n    const { rule } = this.state\n    \n    return (\n    <div>\n      <div className=\"container\">\n        <Form handleSubmit={this.handleSubmit} rule={rule}/>\n        <LSystem rule={rule} />\n      </div>\n    </div>\n    )\n  };\n}\nexport default Home\n","import Immutable from 'immutable'\n\n// A dictionary of organisms. Note\n// that these don't have default X and Y\n// values set, so you're probably going to \n// want to do something like this:\n// \n// myOrganism = Object.assign({}, Organisms.get(\"algae\").rules, {startX: '60', startY: '120'}) \nconst Organisms = Immutable.Map(\n    ).set(\"binaryTree\",\n      {\n        resources: {\n          nitrogen: '-1',\n          oxygen: '+1',\n          carbonDioxide: '-1'\n          \n        },\n        rules: {\n          angle: '25',\n          step: '1',\n          axiom: 'F',\n          replacements: '(G = GG), (F = G[+F]-F)',\n          loops: '6'\n        }\n      }\n    ).set(\"algae\",\n      {\n        resources: {\n          nitrogen: '-1',\n          oxygen: '+1',\n          carbonDioxide: '-1'\n          \n        },\n        rules: {\n          angle: '20',\n          step: '4',\n          axiom: 'F',\n          replacements: '(F = F[+F]F[-F]F)',\n          loops: '3'\n        }\n      }\n    ).set(\"bush\",\n      {\n        resources: {\n          nitrogen: '-1',\n          oxygen: '+1',\n          carbonDioxide: '-1'\n          \n        },\n        rules: {\n          angle: '25',\n          step: '5',\n          axiom: 'X',\n          replacements: '(X = F-[[X]+X]+F[-FX]+X)',\n          loops: '4'\n        }\n      }\n    ).set(\"dragon\",\n      {\n        resources: {\n          nitrogen: '-1',\n          oxygen: '+1',\n          carbonDioxide: '-1'\n          \n        },\n        rules: {\n          angle: '90',\n          step: '2',\n          axiom: 'FX',\n          replacements: '(X = X+YF+), (Y = -FX-Y)',\n          loops: '8'\n        }\n      }\n    ).set(\"fractalPlant\",\n      {\n        resources: {\n          nitrogen: '-1',\n          oxygen: '+1',\n          carbonDioxide: '-1'\n          \n        },\n        rules: {\n          angle: '25',\n          step: '2',\n          axiom: 'X',\n          replacements: '(X = F+[[X]-X]-F[-FX]+X), (F = FF)',\n          loops: '4'\n        }\n      }\n    )\n\nexport default Organisms;","import React, { Component } from 'react'\nimport Immutable from 'immutable'\nimport LSystem from './LSystem'\nimport Organisms from './Organisms'\n\n\nclass Garden extends Component {\n  constructor(props) {\n    super(props)\n    \n    /*\n    The drawArea is 600x600, and we want to divide it into\n    25 squares. Therefore, each organism should take up the following \"plots\":\n    0-120|120, 121-240|120, 241-360|120, 361-480|120, 481-600|120\n    0-120|240, 121-240|240, 241-360|240, 361-480|240, 481-600|240\n    etc.\n    */\n  \n    this.initialState = {\n      organisms: Immutable.List()\n      .push(Object.assign({}, Organisms.get(\"binaryTree\").rules, {startX: '60', startY: '120'}))\n      .push(Object.assign({}, Organisms.get(\"bush\").rules, {startX: '180', startY: '120'}))\n      .push(Object.assign({}, Organisms.get(\"dragon\").rules, {startX: '300', startY: '90'}))\n      .push(Object.assign({}, Organisms.get(\"algae\").rules, {startX: '420', startY: '120'}))\n      .push(Object.assign({}, Organisms.get(\"fractalPlant\").rules, {startX: '540', startY: '120'}))\n      \n      .push(Object.assign({}, Organisms.get(\"fractalPlant\").rules, {startX: '60', startY: '240'}))\n      .push(Object.assign({}, Organisms.get(\"binaryTree\").rules, {startX: '180', startY: '240'}))\n      .push(Object.assign({}, Organisms.get(\"dragon\").rules, {startX: '300', startY: '210'}))\n      .push(Object.assign({}, Organisms.get(\"algae\").rules, {startX: '420', startY: '240'}))\n      .push(Object.assign({}, Organisms.get(\"binaryTree\").rules, {startX: '540', startY: '240'}))\n      \n      .push(Object.assign({}, Organisms.get(\"binaryTree\").rules, {startX: '60', startY: '360'}))\n      .push(Object.assign({}, Organisms.get(\"fractalPlant\").rules, {startX: '180', startY: '360'}))\n      .push(Object.assign({}, Organisms.get(\"fractalPlant\").rules, {startX: '300', startY: '360'}))\n      .push(Object.assign({}, Organisms.get(\"dragon\").rules, {startX: '420', startY: '330'}))\n      .push(Object.assign({}, Organisms.get(\"algae\").rules, {startX: '540', startY: '360'}))\n      \n      .push(Object.assign({}, Organisms.get(\"dragon\").rules, {startX: '60', startY: '450'}))\n      .push(Object.assign({}, Organisms.get(\"bush\").rules, {startX: '180', startY: '480'}))\n      .push(Object.assign({}, Organisms.get(\"dragon\").rules, {startX: '300', startY: '450'}))\n      .push(Object.assign({}, Organisms.get(\"fractalPlant\").rules, {startX: '420', startY: '480'}))\n      .push(Object.assign({}, Organisms.get(\"fractalPlant\").rules, {startX: '540', startY: '480'}))\n      \n      .push(Object.assign({}, Organisms.get(\"dragon\").rules, {startX: '60', startY: '570'}))\n      .push(Object.assign({}, Organisms.get(\"fractalPlant\").rules, {startX: '180', startY: '600'}))\n      .push(Object.assign({}, Organisms.get(\"dragon\").rules, {startX: '300', startY: '570'}))\n      .push(Object.assign({}, Organisms.get(\"algae\").rules, {startX: '420', startY: '600'}))\n      .push(Object.assign({}, Organisms.get(\"fractalPlant\").rules, {startX: '540', startY: '600'}))\n      \n    }\n  \n    this.state = this.initialState\n  }\n  \n  render() {\n    const organisms = this.state.organisms;\n    \n    return (\n    <div>\n      <div className=\"container\">\n      {organisms.map((rule, i) => (\n        <LSystem rule={rule} grow=\"0\" />\n      ))}\n      </div>\n\n    </div>\n    )\n    \n  }\n}\nexport default Garden\n","import React, { Component } from 'react'\nimport {\n  BrowserRouter as Router,\n  Switch,\n  Route,\n  Link\n} from \"react-router-dom\"\nimport Home from './Home'\nimport Garden from './Garden'\n\nclass App extends Component {\n  \n  render() {\n    \n    return (\n    <Router>\n    <p>Welcome to my garden! This is a safe space for L-System plants to grow and flourish. \n    &nbsp; <Link to=\"/\">Home</Link> | <Link to=\"/garden\">Garden</Link></p>\n    \n            \n        <Switch>\n          <Route path=\"/garden\">\n            <Garden />\n          </Route>\n          <Route path=\"/\">\n            <Home />\n          </Route>\n        </Switch>\n      \n    </Router>\n    );\n  }\n  \n  \n  \n}\nexport default App\n","import React from 'react'\nimport ReactDOM from 'react-dom'\nimport './index.css'\nimport App from './App'\n\nReactDOM.render(<App />, document.getElementById('root'))\n"],"sourceRoot":""}