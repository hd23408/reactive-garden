{"version":3,"sources":["TurtleLine.js","TurtleShape.js","LSystem.js","Form.js","App.js","index.js"],"names":["TurtleLine","pathData","this","props","line","map","p","get","join","className","stroke","d","Component","TurtleShape","turtleLines","visibility","index","key","LSystem","sleep","milliseconds","Promise","resolve","setTimeout","state","turtleInstructions","Immutable","List","needsToGrow","currentRule","rule","instructions","axiom","turtleString","expandInstructions","runTurtle","setState","prevState","push","i","loops","inputString","outputString","replacements","split","subst","findString","replace","trim","newString","token","matched","replacement","angle","Math","PI","item","currentAngle","currentX","Number","startX","currentY","startY","locations","Stack","lines","step","c","point1","Map","x","y","cos","toRadians","sin","point2","currPos","X","Y","A","oldPos","first","pop","inGrowth","drawLSystem","grow","nextProps","nextState","previousProps","previousState","turtle","Form","handleChange","event","target","name","value","submitForm","handleSubmit","initialState","type","size","onChange","onClick","App","newRule","ReactDOM","render","document","getElementById"],"mappings":"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","file":"static/js/main.9a3923c1.chunk.js","sourcesContent":["import React, { Component } from 'react'\n\nclass TurtleLine extends Component {  \n  render() {\n    const { line } = this.props\n    \n    const pathData = \"M \" + line\n      .map(p => p.get('x') + ' ' + p.get('y'))\n      .join(\" L \");\n\n    return <path className='path' stroke='black' d={pathData} />;\n  }\n}\n\nexport default TurtleLine;\n","import React, { Component } from 'react'\nimport TurtleLine from './TurtleLine'\n\nclass TurtleShape extends Component {  \n  \n  render() {\n    const turtleLines = this.props.turtleLines;\n    const visibility = this.props.visibility;\n    \n    return (\n      <div>\n      <svg className={visibility}>\n        {turtleLines.map((line, index) => (\n          <TurtleLine key={index} line={line} />\n        ))}\n      </svg>\n      </div>\n    );\n    \n  }\n}\n\nexport default TurtleShape;\n","import React, { Component } from 'react'\nimport Immutable from 'immutable'\nimport TurtleShape from './TurtleShape'\n\nclass LSystem extends Component {\n  constructor(props) {\n    /*\n      The propery handed in should be an object called \"rule\", with\n      the following keys:\n        axiom: The initial string\n        numloops: How many times to run the replacement algorithm\n        replacements: One or more comma-separated replacement rules, of the format \"X = Y\" \n        step: How many pixels to draw each line\n        angle: The angle to turn when turning\n        startX: The X position at which to start drawing\n        startY: The Y position at which to start drawing\n    */\n    super(props);\n    \n    /*\n      In this component's state, we'll keep track of the following:\n        turtleInstructions: A list of the expanded instructions (one entry for\n            each loop through the rewriting process)\n        turtleLines: A list of structures which contain the following:\n            visibility: The class names for the wrapping svg object \n            lines: A list of the actual TurtleLine components that will get rendered\n        needsToGrow: For complicated React reasons, a boolean indicating whether or not\n            we've gone through the \"growing\" render process for this particular L-System\n    */\n    this.state = {\n      turtleInstructions: new Immutable.List(),\n      turtleLines: new Immutable.List(),\n      needsToGrow: false,\n    }\n\n  }\n  \n  /*\n    The main function that will generate the turtle drawing instructions\n    for each iteration, and populate this.state accordingly.\n  */\n  drawLSystem() {\n    const currentRule = this.props.rule;  // The information about how to build the system\n    var instructions = currentRule.axiom; // The starting point\n    \n    // Loop N times, and for each loop, expand the instructions\n    // and create the relevant TurtleLines\n    for (var i = 0; i < currentRule.loops; i++) {\n      const turtleString = this.expandInstructions(instructions);\n      const turtleLines = this.runTurtle(turtleString);\n        \n      // Add this loop's instructions and TurtleLines to our state\n      this.setState(prevState => {\n        return {\n          turtleInstructions: prevState.turtleInstructions.push(turtleString),\n          turtleLines: prevState.turtleLines.push(turtleLines),\n        };\n      }); \n      \n      // Reset the instructions to the current turtle string in preparation for the next loop\n      instructions = turtleString;\n    }\n    \n    // After we're done updating state with all of the appropriate turtle lines,\n    // indicate to ourselves that we need to grow. (i.e. to show the actual rendering of the lines)\n    this.setState(prevState => {\n        return {\n          needsToGrow: true,\n        };\n    });\n  }\n  \n  \n  /* \n    Expansion function for a given \"loop\" of instruction generation\n  */\n  expandInstructions(inputString) {\n    \n    var outputString = '';\n    var replacements = [];\n    const currentRule = this.props.rule;\n    \n    for(const replacement of currentRule.replacements.split(',')) {\n      const rule = replacement.split('=');\n      const subst = {findString: rule[0].replace(/\\(/,\"\").trim(), newString: rule[1].replace(/\\)/,\"\").trim()};\n      replacements.push(subst);\n    }\n    \n    for(const token of inputString) {\n      var matched = false;\n      for(const replacement of replacements) {\n        if (replacement.findString === token) {\n          matched = true;\n          outputString += replacement.newString;\n          break;\n        }  \n      }\n      if (! matched) outputString += token;\n    }\n    return outputString;\n  }\n  \n  /*\n    Utility function for converting to radians to make the math easier\n  */\n  toRadians(angle) {\n    return angle * (Math.PI / 180);\n  }\n  \n  /*\n    Function to send the turtle along the path of following a particular\n    instruction set and drawing out the lines necessary for it; note that\n    these lines are hidden to begin with, and need to go through the \"grow\"\n    process in order to be visible\n  */\n  runTurtle(item) {\n\n    const instructions = item;\n    const currentRule = this.props.rule;\n    \n    var currentAngle = 90;\n    var currentX = Number(currentRule.startX);\n    var currentY = Number(currentRule.startY);\n    var locations = Immutable.Stack();\n    \n    // This structure is what we'll ultimately add to this.state.turtleLines;\n    // note that it's hidden by default\n    var turtleLines = {\n      visibility: \"hidden drawArea\",\n      lines: Immutable.List(),\n    };\n    \n    const angle = Number(currentRule.angle);\n    const step = Number(currentRule.step);\n    \n    // For each character in the string\n    for(const c of instructions) {\n      if (c === 'F' || c === 'G') {\n        // If it's an \"F\" or a \"G\", add a line and move the turtle\n        const point1 = new Immutable.Map({x: currentX, y: currentY,});\n        currentX = currentX + step * Math.cos(this.toRadians(currentAngle));\n        currentY = currentY - step * Math.sin(this.toRadians(currentAngle));\n        const point2 = new Immutable.Map({x: currentX, y: currentY,});\n        \n        turtleLines.lines = turtleLines.lines.push(Immutable.List([point1, point2]));\n        \n      } else if (c === '+') {\n        // If it's a turn, change the angle\n        currentAngle += angle; // turn left\n      } else if (c === '-') {\n        currentAngle -= angle; // turn right)\n      } else if (c === '[') {\n        // Push current value of X,Y from locations\n        const currPos = {X: currentX, Y: currentY, A: currentAngle};\n        locations = locations.push(currPos);\n      } else if (c === ']') {\n        // Reset current value of X,Y to that popped from locations\n        const oldPos = locations.first();\n        locations = locations.pop();\n        currentX = oldPos.X;\n        currentY = oldPos.Y;\n        currentAngle = oldPos.A;\n      } else if (c === 'X' || c === 'Y') {\n        // For completeness; no-op\n      }\n    }\n    return turtleLines;\n  }\n  \n  \n  /*\n    Utility method for sleeping (ugh javascript)\n  */\n  sleep = (milliseconds) => {\n    return new Promise(resolve => setTimeout(resolve, milliseconds))\n  }\n  \n  /*\n    Function that will gradually show each of the sets of lines (the\n    svg objects) such that the system appears to \"grow\"\n  */\n  async grow(){\n    const turtleLines = this.state.turtleLines;\n    const currentRule = this.props.rule;\n    \n    this.setState(prevState => {\n        return {\n          needsToGrow: false,\n          inGrowth: true,\n        };\n    });\n    \n    for (var i = 0; i < currentRule.loops; i++) {  \n      if (i !== 0) {\n        turtleLines.get(i-1).visibility = \"hidden drawArea\";\n      }\n      turtleLines.get(i).visibility = \"drawArea\";\n      this.setState(prevState => {\n        return {\n          turtleLines: turtleLines,\n        };\n      }); \n      await this.sleep(250);\n    }\n    \n  }\n  \n\n  // ----------- OVERRIDING COMPONENT METHODS BELOW HERE ----------------\n  \n  // Before it first loads, run the\n  // turtle to draw the needed lines.\n  componentWillMount() {\n    this.drawLSystem();\n  }\n  \n  // And, after everything is drawn and\n  // loaded, \"grow\" the system\n  componentDidMount() {\n    this.grow();\n  }\n  \n  \n  // We only want to actually update the component under three conditions:\n  // 1) If the rule has changed\n  // 2) If we need to \"grow\" the system\n  // 3) If we're actually in the process of growing the system\n  shouldComponentUpdate(nextProps, nextState) {\n    return nextProps.rule !== this.props.rule || this.state.needsToGrow || this.state.inGrowth;\n  }\n  \n  \n  // Every time an update happens, check to see if \n  // our parent has changed our rules and, if so, recreate\n  // the lines\n  componentDidUpdate(previousProps, previousState) {\n\n    // Because componentDidUpdate will get called on\n    // any update of state (including, for instance,\n    // adding a new line), only reset and redraw\n    // if the thing being changed is the rule. (Note\n    // that because we've overridden shouldComponentUpdate we \n    // should never get here in the first place, but we're\n    // being safe.)\n    if (previousProps.rule !== this.props.rule) {\n      // The rule has been changed;\n      // reset our state. \n      this.setState(prevState => {\n        return {\n          turtleInstructions: Immutable.List(),\n          turtleLines: Immutable.List(),\n          needsToGrow: false,\n          inGrowth: false,\n        };\n      }); \n      this.drawLSystem();\n    } else if (this.state.needsToGrow) {\n      // We need to grow! Call the \"grow\"\n      // function.\n      this.grow();\n    }\n  }\n  \n\n  /*\n   The actual render, finally!\n */\n  render() {\n    const turtleLines = this.state.turtleLines;\n    \n    return (\n      <div>\n      {turtleLines.map((turtle, i) => (\n        <TurtleShape visibility={turtle.visibility} turtleLines={turtle.lines} />\n      ))}\n    </div>\n    );\n  }\n}\n\nexport default LSystem;\n","import React, { Component } from 'react'\n\nclass Form extends Component {\n  constructor(props) {\n    super(props)\n\n    this.initialState = {\n      angle: props.rule.angle,\n      step: props.rule.step,\n      axiom: props.rule.axiom,\n      replacements: props.rule.replacements,\n      loops: props.rule.loops,\n      startX: props.rule.startX,\n      startY: props.rule.startY\n    }\n\n    this.state = this.initialState\n  }\n  \n  handleChange = event => {\n    const { name, value } = event.target\n  \n    this.setState({\n      [name]: value,\n    })\n  }\n  \n  submitForm = () => {\n    this.props.handleSubmit(this.state)\n  }\n  \n  render() {\n    const { angle,\n      step,\n      axiom,\n      replacements,\n      loops,\n      startX,\n      startY } = this.state;\n  \n    return (\n      \n      <div className=\"instructions\">\n      <h3>Instructions</h3>\n      <p>\n        To run an L-System, enter the required information and press \"submit\". Some notes:\n        <ul>\n        <li>The \"Replacement Rule\" should consist one or more comma-separated replacement rules, of the format \"( X = Y )\" -- see examples, below</li>\n        <li>PLEASE don't use more than 6 recursions!</li>\n        <li>If you're having trouble seeing the entire resulting drawing, try reducing the \"Step Size\" to make it smaller</li>\n        <li>NOTE: INPUTS ARE NOT CURRENTLY BEING SANITIZED! If you get an error, probably it's a parsing issue. Check your rules in particular.</li>\n        </ul>\n      </p>\n      \n      <hr />\n      \n      <h3>L-System rules</h3>\n      <form>\n        <label>Axiom (initial string)</label>\n        <input\n          type=\"text\"\n          name=\"axiom\"\n          size=\"10\"\n          value={axiom}\n          onChange={this.handleChange} />\n        \n        <br />\n        <label>Replacement Rules</label>\n        <input\n          type=\"text\"\n          name=\"replacements\"\n          size=\"50\"\n          value={replacements}\n          onChange={this.handleChange} />\n        \n        <br />\n        <label>Angle for Turns</label>\n        <input\n          type=\"text\"\n          name=\"angle\"\n          size=\"5\"\n          value={angle}\n          onChange={this.handleChange} />\n          \n        <br />\n        <label>Step Size (length of line)</label>\n        <input\n          type=\"text\"\n          name=\"step\"\n          size=\"5\"\n          value={step}\n          onChange={this.handleChange} />\n          \n        <br />\n        <label>Loops (number of recursions)</label>\n        <input\n          type=\"text\"\n          name=\"loops\"\n          size=\"5\"\n          value={loops}\n          onChange={this.handleChange} />\n          \n        <br />\n        <label>Initial X Position</label>\n        <input\n          type=\"text\"\n          name=\"startX\"\n          size=\"5\"\n          value={startX}\n          onChange={this.handleChange} />\n        <label>Initial Y Position</label>\n        <input\n          type=\"text\"\n          name=\"startY\"\n          size=\"5\"\n          value={startY}\n          onChange={this.handleChange} />\n          \n        <br />\n        <input type=\"button\" value=\"Submit\" onClick={this.submitForm} />\n      </form>\n      \n      <hr />\n      \n      <h3>Examples</h3>\n      <p>\n      <ul>\n      <li>Sierpinski triangle:\n        <ul>\n          <li>Axiom: F-G-G</li>\n          <li>Replacement Rules: (F = F-G+F+G-F), (G = GG)</li>\n          <li>Angle: 120</li>\n          <li>Step Size: 7</li>\n          <li>Loops: 6</li>\n          <li>Initial X: 10</li>\n          <li>Initial Y: 600</li>\n        </ul>\n      </li>\n      \n      <li>Fractal plant:\n        <ul>\n          <li>Axiom: X</li>\n          <li>Replacement Rules: (X = F+[[X]-X]-F[-FX]+X), (F = FF)</li>\n          <li>Angle: 25</li>\n          <li>Step Size: 3</li>\n          <li>Loops: 6</li>\n          <li>Initial X: 200</li>\n          <li>Initial Y: 600</li>\n        </ul>\n      </li>\n      \n      \n      <li>Koch curve\n        <ul>\n          <li>Axiom: F</li>\n          <li>Replacement Rules: (F = F+F-F-F+F)</li>\n          <li>Angle: 90</li>\n          <li>Step Size: 4</li>\n          <li>Loops: 4</li>\n          <li>Initial X: 300</li>\n          <li>Initial Y: 600</li>\n        </ul>\n      </li>\n      \n      \n      <li>Dragon curve\n        <ul>\n          <li>Axiom: FX</li>\n          <li>Replacement Rules: (X = X+YF+), (Y = -FX-Y)</li>\n          <li>Angle: 90</li>\n          <li>Step Size: 4</li>\n          <li>Loops: 12 <i>(Dragons get special dispensation for extra loops)</i></li>\n          <li>Initial X: 300</li>\n          <li>Initial Y: 200</li>\n        </ul>\n      </li>\n      \n      </ul>\n      </p>\n      </div>\n    );\n  }\n}\n\n  export default Form;","import React, { Component } from 'react'\nimport LSystem from './LSystem'\nimport Form from './Form'\n\nclass App extends Component {\n  constructor(props) {\n    super(props)\n  \n    this.initialState = {\n      // Sierpinski triangle\n      rule: {\n        angle: '120',\n        step: '7',\n        axiom: 'F-G-G',\n        replacements: '(F = F-G+F+G-F), (G = GG)',\n        loops: '6',\n        startX: '10',\n        startY: '600'\n      }\n    }\n  \n    this.state = this.initialState\n  }\n\n  handleSubmit = newRule => {\n    this.setState({ rule: newRule });\n  }\n\n  \n  render() {\n    const { rule } = this.state\n    \n    return (\n    <div>\n      <div className=\"container\">\n        <Form handleSubmit={this.handleSubmit} rule={rule}/>\n        <LSystem rule={rule} />\n      </div>\n\n    </div>\n    )\n    \n  }\n}\nexport default App\n","import React from 'react'\nimport ReactDOM from 'react-dom'\nimport './index.css'\nimport App from './App'\n\nReactDOM.render(<App />, document.getElementById('root'))\n"],"sourceRoot":""}