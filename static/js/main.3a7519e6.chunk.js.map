{"version":3,"sources":["TurtleLine.js","LSystem.js","App.js","index.js"],"names":["TurtleLine","pathData","this","props","line","map","p","get","join","class","stroke","d","Component","LSystem","state","lines","Immutable","List","rules","axiom","i","loops","expandRules","inputString","outputString","replacements","split","rule","subst","findString","replace","trim","newString","push","token","matched","replacement","angle","Math","PI","currentAngle","currentX","currentY","locations","Stack","Number","step","generateRules","c","point1","Map","x","y","cos","toRadians","sin","point2","setState","prevState","currPos","X","Y","A","oldPos","first","pop","runTurtle","index","key","App","ReactDOM","render","document","getElementById"],"mappings":"2OAceA,E,iLAXH,IAGFC,EAAW,KAFAC,KAAKC,MAAdC,KAGLC,KAAI,SAAAC,GAAC,OAAIA,EAAEC,IAAI,KAAO,IAAMD,EAAEC,IAAI,QAClCC,KAAK,OAER,OAAO,0BAAMC,MAAM,OAAOC,OAAO,QAAQC,EAAGV,Q,GARvBW,aC8HVC,E,YA1Hb,WAAYV,GAAQ,IAAD,8BASjB,4CAAMA,KAGDW,MAAQ,CACXC,MAAO,IAAIC,IAAUC,MAbN,E,6EAoBjB,IADA,IAAIC,EAAQhB,KAAKC,MAAMgB,MACdC,EAAI,EAAGA,EAAIlB,KAAKC,MAAMkB,MAAOD,IACpCF,EAAQhB,KAAKoB,YAAYJ,GAE3B,OAAOA,I,kCAGGK,GACV,IAAIC,EAAe,GACfC,EAAe,GAFI,uBAIvB,IAAI,IAAJ,IAAyBvB,KAAKC,MAAMsB,aAAaC,MAAM,KAAvD,+CAA6D,CAAC,IACtDC,EADqD,QAClCD,MAAM,KACzBE,EAAQ,CAACC,WAAYF,EAAK,GAAGG,QAAQ,KAAK,IAAIC,OAAQC,UAAWL,EAAK,GAAGG,QAAQ,KAAK,IAAIC,QAEhGN,EAAaQ,KAAKL,IARG,6GAWvB,IAAI,IAAJ,IAAmBL,EAAnB,+CAAgC,CAAC,IAAvBW,EAAsB,QAC1BC,GAAU,EADgB,uBAE9B,IAAI,IAAJ,IAAyBV,EAAzB,+CAAuC,CAAC,IAA9BW,EAA6B,QACrC,GAAIA,EAAYP,aAAeK,EAAO,CACpCC,GAAU,EACVX,GAAgBY,EAAYJ,UAC5B,QAN0B,kFAUxBG,IAASX,GAAgBU,IArBV,kFAyBvB,OAAOV,I,gCAGEa,GACT,OAAOA,GAASC,KAAKC,GAAK,O,kCAGf,IAAD,OACNC,EAAe,GACfC,EAAW,IACXC,EAAW,IACXC,EAAY3B,IAAU4B,QAEpBP,EAAQQ,OAAO3C,KAAKC,MAAMkC,OAC1BS,EAAOD,OAAO3C,KAAKC,MAAM2C,MACzB5B,EAAQhB,KAAK6C,gBART,uBAWV,IAAI,IAAJ,IAAe7B,EAAf,+CAAsB,CAAC,IAAb8B,EAAY,QACpB,GAAU,MAANA,GAAmB,MAANA,GAAY,WAE3B,IAAMC,EAAS,IAAIjC,IAAUkC,IAAI,CAACC,EAAGV,EAAUW,EAAGV,IAClDD,GAAsBK,EAAOR,KAAKe,IAAI,EAAKC,UAAUd,IACrDE,GAAsBI,EAAOR,KAAKiB,IAAI,EAAKD,UAAUd,IACrD,IAAMgB,EAAS,IAAIxC,IAAUkC,IAAI,CAACC,EAAGV,EAAUW,EAAGV,IAElD,EAAKe,UAAS,SAAAC,GACZ,MAAO,CACL3C,MAAO2C,EAAU3C,MAAMkB,KAAKjB,IAAUC,KAAK,CAACgC,EAAQO,SAT7B,QAYtB,GAAU,MAANR,EAETR,GAAgBH,OACX,GAAU,MAANW,EACTR,GAAgBH,OACX,GAAU,MAANW,EAAW,CAEpB,IAAMW,EAAU,CAACC,EAAGnB,EAAUoB,EAAGnB,EAAUoB,EAAGtB,GAC9CG,EAAYA,EAAUV,KAAK0B,QACtB,GAAU,MAANX,EAAW,CAEpB,IAAMe,EAASpB,EAAUqB,QACzBrB,EAAYA,EAAUsB,MACtBxB,EAAWsB,EAAOH,EAClBlB,EAAWqB,EAAOF,EAClBrB,EAAeuB,EAAOD,IAvChB,qF,0CAiDV5D,KAAKgE,c,+BAIL,IAAMnD,EAAQb,KAAKY,MAAMC,MACzB,OACE,yBAAKN,MAAM,YACVM,EAAMV,KAAI,SAACD,EAAM+D,GAAP,OACT,kBAAC,EAAD,CAAYC,IAAKD,EAAO/D,KAAMA,Y,GApHhBQ,aCoBPyD,E,iLAlBX,OAWE,kBAAC,EAAD,CAAShC,MAAM,KAAKS,KAAK,IAAI3B,MAAM,KAAKM,aAAa,2BAA2BJ,MAAM,W,GAf1ET,aCElB0D,IAASC,OAAO,kBAAC,EAAD,MAASC,SAASC,eAAe,U","file":"static/js/main.3a7519e6.chunk.js","sourcesContent":["import React, { Component } from 'react'\n\nclass TurtleLine extends Component {  \n  render() {\n    const { line } = this.props\n    \n    const pathData = \"M \" + line\n      .map(p => p.get('x') + ' ' + p.get('y'))\n      .join(\" L \");\n\n    return <path class='path' stroke='black' d={pathData} />;\n  }\n}\n\nexport default TurtleLine;\n","import React, { Component } from 'react'\nimport Immutable from 'immutable'\nimport TurtleLine from './TurtleLine'\n\n\nclass LSystem extends Component {\n  constructor(props) {\n    /*\n      Expected props:\n        axiom: The initial string\n        numloops: How many times to run the replacement algorithm\n        replacements: One or more comma-separated replacement rules, of the format \"X = Y\" \n        step: How many pixels to draw each line\n        angle: The angle to turn when turning\n    */\n    super(props);\n    \n    // An empty list of lines that will be filled in when drawing\n    this.state = {\n      lines: new Immutable.List(),\n    }\n\n  }\n  \n  generateRules() {\n    var rules = this.props.axiom;\n    for (var i = 0; i < this.props.loops; i++) {\n      rules = this.expandRules(rules);\n    }\n    return rules;\n  }\n  \n  expandRules(inputString) {\n    var outputString = '';\n    var replacements = [];\n    \n    for(const replacement of this.props.replacements.split(',')) {\n      const rule = replacement.split('=');\n      const subst = {findString: rule[0].replace(/\\(/,\"\").trim(), newString: rule[1].replace(/\\)/,\"\").trim()};\n      \n      replacements.push(subst);\n    }\n    \n    for(const token of inputString) {\n      var matched = false;\n      for(const replacement of replacements) {\n        if (replacement.findString === token) {\n          matched = true;\n          outputString += replacement.newString;\n          break;\n        }  \n      }\n      \n      if (! matched) outputString += token;\n    }\n    \n      \n    return outputString;\n  }\n  \n  toRadians (angle) {\n    return angle * (Math.PI / 180);\n  }\n  \n  runTurtle() {\n    var currentAngle = 90;\n    var currentX = 300;\n    var currentY = 300;\n    var locations = Immutable.Stack();\n    \n    const angle = Number(this.props.angle);\n    const step = Number(this.props.step);\n    const rules = this.generateRules();\n    \n    // For each character in the string\n    for(const c of rules) {\n      if (c === 'F' || c === 'G') {\n        // If it's an \"F\", add a line and move the turtle\n        const point1 = new Immutable.Map({x: currentX, y: currentY,});\n        currentX = currentX + step * Math.cos(this.toRadians(currentAngle));\n        currentY = currentY - step * Math.sin(this.toRadians(currentAngle));\n        const point2 = new Immutable.Map({x: currentX, y: currentY,});\n        \n        this.setState(prevState => {\n          return {\n            lines: prevState.lines.push(Immutable.List([point1, point2])),\n          };\n        });\n      } else if (c === '+') {\n        // If it's a turn, change the angle\n        currentAngle += angle; // turn left\n      } else if (c === '-') {\n        currentAngle -= angle; // turn right)\n      } else if (c === '[') {\n        // Push current value of X,Y from locations\n        const currPos = {X: currentX, Y: currentY, A: currentAngle};\n        locations = locations.push(currPos);\n      } else if (c === ']') {\n        // Reset current value of X,Y to that popped from locations\n        const oldPos = locations.first();\n        locations = locations.pop();\n        currentX = oldPos.X;\n        currentY = oldPos.Y;\n        currentAngle = oldPos.A;\n        //alert(\"now at \" + currentX)\n      } else if (c === 'X' || c === 'Y') {\n        // For completeness; no-op\n      }\n    }\n  }\n  \n  \n  componentDidMount() {\n    this.runTurtle();\n  }\n  \n  render() {\n    const lines = this.state.lines;\n    return (\n      <svg class=\"drawArea\">\n      {lines.map((line, index) => (\n        <TurtleLine key={index} line={line} />\n      ))}\n    </svg>\n    );\n  }\n}\n\nexport default LSystem;\n","import React, { Component } from 'react'\nimport LSystem from './LSystem'\n\nclass App extends Component {\n  \n  render() {\n    \n    return (\n      // Sierpinski triangle:\n      // <LSystem angle=\"120\" step=\"7\" axiom=\"F-G-G\" replacements=\"(F = F-G+F+G-F), (G = GG)\" loops=\"6\"/>\n      \n      // Fractal plant:\n      // <LSystem angle=\"25\" step=\"3\" axiom=\"X\" replacements=\"(X = F+[[X]-X]-F[-FX]+X), (F = FF)\" loops=\"6\"/>\n      \n      // Koch curve:\n      // <LSystem angle=\"90\" step=\"10\" axiom=\"F\" replacements=\"(F = F+F-F-F+F)\" loops=\"6\"/>\n      \n      // Dragon curve:\n      <LSystem angle=\"90\" step=\"4\" axiom=\"FX\" replacements=\"(X = X+YF+), (Y = -FX-Y)\" loops=\"12\"/>\n      \n    )\n    \n\n  }\n}\nexport default App\n","import React from 'react'\nimport ReactDOM from 'react-dom'\nimport './index.css'\nimport App from './App'\n\nReactDOM.render(<App />, document.getElementById('root'))\n"],"sourceRoot":""}